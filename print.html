<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GBA From Scratch With Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="initial-setup/index.html"><strong aria-hidden="true">1.</strong> Initial Setup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="initial-setup/minimal-example.html"><strong aria-hidden="true">1.1.</strong> A Minimal Example</a></li><li class="chapter-item expanded "><a href="initial-setup/calling-main.html"><strong aria-hidden="true">1.2.</strong> Calling main</a></li><li class="chapter-item expanded "><a href="initial-setup/volatile-ops.html"><strong aria-hidden="true">1.3.</strong> Volatile Ops</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GBA From Scratch With Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Lokathor/gba-from-scratch-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <em>GBA From Scratch With Rust</em>.</p>
<p>It's a book about programming for the Game Boy Advance using the Rust programming langauge.
Particularly, everything will be as &quot;from scratch&quot; as possible.
This means that we'll use the <code>core</code> part of the standard library,
but for all other code it'll be stuff we've covered how to make in the book.</p>
<p>If you want to write 20 lines of code to call a few library functions and have a working Pong clone, this book is <strong>NOT</strong> for you.
This is <em>not</em> the quick path to having a completed game.
This is the much slower path of learning how all the things are happening under the hood.
If that kind of thing sounds like fun, then this book is probably for you.</p>
<p>Doing things from scratch is <em>not</em> a time-efficient way to complete a project,
but it is a pretty good way to learn about all the layers that go into something.</p>
<h2 id="expected-background"><a class="header" href="#expected-background">Expected Background</a></h2>
<p>The primary expected background for reading is book is a basic understanding of the Rust language itself.
You'll also need to be familiar with using <code>cargo</code> based projects, which most every Rust programmer already is.
The usual way to learn Rust is by reading <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>,
but any similar introduction to the language should suffice.</p>
<p>We will definitely be using many advanced features of Rust to get things done,
but those parts I will explain as we go.</p>
<p>Also, a general familiarity with using command line tools is probably a good idea,
but if you're familiar with <code>cargo</code> then you probably know enough to get started.</p>
<h2 id="reporting-a-problem"><a class="header" href="#reporting-a-problem">Reporting A Problem</a></h2>
<p>If there's some sort of problem with the book,
such as an explanation not being clear,
then please open an <a href="https://github.com/Lokathor/gba-from-scratch-rs/issues">issue</a> in the GitHub repository.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This book is available under the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International</a> license.
Also known as &quot;CC BY-NC-SA 4.0&quot;, for short.
In simple terms it means that you can redistribute this book (with or without changes) as long as you give credit,
as long as it's not for commercial purposes,
and as long as you don't change the license.
If you need more details you can follow the link and read the full text of the license.</p>
<h2 id="support-the-project"><a class="header" href="#support-the-project">Support The Project</a></h2>
<p>If you'd like to support the book you can sign up to be a <a href="https://github.com/sponsors/Lokathor">Github Sponsor</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-setup"><a class="header" href="#initial-setup">Initial Setup</a></h1>
<blockquote>
<p>If you want to make an apple pie from scratch, you must first invent the universe.</p>
</blockquote>
<p>In other words, we've got a lot of setup ahead of us.</p>
<h1 id="system-tooling-setup"><a class="header" href="#system-tooling-setup">System Tooling Setup</a></h1>
<p>Separately from setting up a specific project's configuration, you'll need to do a few &quot;one time&quot; things to make your machine ready.</p>
<p>First of all, we'll need to be using the Nightly rust compiler, because we'll be using a lot of unstable features.</p>
<p>Next, we'll need to have the <code>rust-src</code> rustup component available, because we'll have to build our own copy of the standard library.</p>
<p>Finally, we'll need the ARM binutils because LLVM's linker doesn't currently support the GBA's old CPU (but support is in the works).
You can get the ARM binutils for Windows and Mac from the <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">ARM Developer Website</a>.
If you're on Linux then you can probably find them in your package manager.
We want a set of binutils for <code>arm-none-eabi</code>.</p>
<p>Here's the lines to make the (ubuntu based) CI run:</p>
<pre><code class="language-sh">rustup default nightly
rustup component add rust-src
sudo apt-get install -y binutils-arm-none-eabi
</code></pre>
<p>The <code>rust-src</code> component will be specific to Nightly or Stable, so be sure to set Nightly before installing it.
Otherwise you'll just have to install it a second time after setting Nightly for use.</p>
<p>The rustup commands should work just as well on Windows and Mac.
If you're on a Linux that isn't Ubuntu then the binutils package could be under some other name.</p>
<p><strong>Note:</strong> <code>rustup default nightly</code> is a global command and will affect all your rust stuff.
If you want to sets nightly for <em>only</em> your GBA project the consider a <a href="https://rust-lang.github.io/rustup/overrides.html?#the-toolchain-file">toolchain file</a> instead.</p>
<p>We'll also need a tool called <code>gbafix</code>, which can patch up the ROM's header data.
There's a <a href="https://github.com/devkitPro/gba-tools">C version</a> of that if you want,
but there's also a rust one too, and you can just get the Rust version via <code>cargo install</code>.</p>
<pre><code class="language-sh">cargo install gbafix
</code></pre>
<h1 id="project-configuration"><a class="header" href="#project-configuration">Project Configuration</a></h1>
<p>In addition to the system level setup, we'll want to set a few project configuration files before we begin working on the actual code.</p>
<h2 id="cargotoml"><a class="header" href="#cargotoml"><code>Cargo.toml</code></a></h2>
<p>Running the usual <code>cargo init</code> will make a default <code>Cargo.toml</code> file.
This is mostly fine, but I strongly suggest that we alter the &quot;dev&quot; build profile slightly.
The dev profile is what's used for debug builds.
Normally the dev profile is set for a low level of optimization and using incremental building.
This lets debug builds complete quickly, though the resulting programs run an order of magnitude (or more) slower than a release build.
The GBA has a very weak CPU, so taking such a performance hit, even just in debug builds, is very bad for us.</p>
<p>We want to turn the <code>opt-level</code> up to 3, and turn <code>incremental</code> off.</p>
<p>Also, we can use a package override to turn <code>debug-assertions</code> off in our dependencies.
We won't have any normal dependencies, but we'll be using the <code>build-std</code> nightly feature of <code>cargo</code>.
When <code>cargo</code> builds the standard library it'll pull in <code>compiler_builtins</code>, and we want that to avoid those debug asserts.</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 3
incremental = false

[profile.dev.package.&quot;*&quot;]
debug-assertions = false
</code></pre>
<h2 id="cargoconfigtoml"><a class="header" href="#cargoconfigtoml"><code>.cargo/config.toml</code></a></h2>
<p>In our project folder make a <code>.cargo/</code> folder, then make a <code>cargo.toml</code> file inside.
This lets us change a few more cargo defaults so that we don't need to pass as many command line arguments all the time.</p>
<p>First of all, our default target for all of our builds will be <code>thumbv4t-none-eabi</code>.
There's two targets built in to <code>rustc</code> that could work on the GBA:</p>
<ul>
<li><code>thumbv4t-none-eabi</code> produces &quot;thumb code&quot; by default</li>
<li><code>armv4t-none-eabi</code> produces &quot;arm code&quot; by default</li>
</ul>
<p>We'll cover the thumb/arm differences later,
for now just know that we'll want a majority of our code to be thumb code so we'll be building with <code>thumbv4t-none-eabi</code>.
We can set this with <code>--target=thumbv4t-none-eabi</code>, but we can also use a <code>[build]</code> entry.</p>
<pre><code class="language-toml">[build]
target = &quot;thumbv4t-none-eabi&quot;
</code></pre>
<p>The thing is, there's no standard library shipped for this target, it's only &quot;<a href="https://doc.rust-lang.org/rustc/target-tier-policy.html">Tier 3</a>&quot;.
This isn't a very big problem, because a Nightly feature of <code>cargo</code> lets us build it ourselves.
It makes a fresh project build take an extra few seconds, but that's it.
We could do this with <code>-Zbuild-std=core</code>, or we can use an <code>[unstable]</code> entry.</p>
<pre><code class="language-toml">[unstable]
build-std = [&quot;core&quot;]
</code></pre>
<p>Last up is that we want to set some per-target details.
With a <code>runner</code> we can name a program that will run our programs.
This is designed to support emulators and simulators and the like, which is exactly what we want.
My GBA emulator of choice is <a href="https://mgba.io/">mGBA</a> because it supports running ELF files directly.
This greatly simplifies the process of running our game in the emulator during development.
We set mGBA as the <code>runner</code>, then <code>cargo</code> passes our ELF formatted executable as an arg to mGBA, and things will &quot;just work&quot;.
On Linux and Mac you'll get two executables when you install mGBA: <code>mgba</code> will have no GUI controls, and <code>mgba-qt</code> will have GUI controls.
On Windows there's just one executable: <code>mgba.exe</code>.
Personally, on my Windows machine I just made a copy of <code>mgba.exe</code> called <code>mgba-qt.exe</code> so that &quot;mgba-qt&quot; works all the time.</p>
<p>In addition to the <code>runner</code>, we need to set some special <code>rustflags</code>.
There's a special argument we need to pass to the linker.
We do this with <code>-Clink-arg=</code>, followed by the argument.
The linker argument itself that we need to pass will be to set the linker script.
We do this with <code>-T</code>, followed by the script's filename.
I'm going to suggest having a folder called <code>linker_scripts/</code>, and then a script called <code>mono_boot.ld</code>.
That means that our <code>[target.thumbv4t-none-eabi]</code> entry will look like this</p>
<pre><code class="language-toml">[target.thumbv4t-none-eabi]
runner = &quot;mgba-qt&quot;
rustflags = [&quot;-Clink-arg=-Tlinker_scripts/mono_boot.ld&quot;]
</code></pre>
<p>The linker script file itself is complicated enough to deserve its own sub-header.</p>
<h2 id="linker_scriptsmono_bootld"><a class="header" href="#linker_scriptsmono_bootld"><code>linker_scripts/mono_boot.ld</code></a></h2>
<p>In a folder called <code>linker_scripts/</code> we want a file called <code>mono_boot.ld</code>.
This is a configuration file for the linker.</p>
<p>The actual content of the linker script is long enough that I won't paste it all in here.
Just get it out of the github repo: <a href="https://github.com/Lokathor/gba-from-scratch-rs/blob/main/linker_scripts/mono_boot.ld">mono_boot.ld</a></p>
<p>There is a <a href="https://sourceware.org/binutils/docs/ld/">sizable manual</a> for how the linker works.
It includes a full description of how linker scripts operate.
Actually understanding how the linker script works isn't necessary right now, or ever.
The only reason we need this extra linker script file at all is because the GBA is a more obscure target than a desktop or phone or something like that.
If we were compiling for a common platform the compiler would still follow a linker script, it would just use one that came with the linker instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimal-example"><a class="header" href="#minimal-example">Minimal Example</a></h1>
<p>The most minimal example we could start with doesn't do anything except avoid crashing.
Still, it's a useful way to check that our tools and project are configured properly.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]
#![feature(naked_functions)]

<span class="boring">fn main() {
</span>#[naked]
#[no_mangle]
#[instruction_set(arm::a32)]
#[link_section = &quot;.text.gba_rom_header&quot;]
unsafe extern &quot;C&quot; fn __start() -&gt; ! {
  core::arch::asm! {
    &quot;b 1f&quot;,
    &quot;.space 0xE0&quot;,
    &quot;1:&quot;,
    &quot;b 1b&quot;,
    options(noreturn)
  }
}

#[panic_handler]
fn handle_panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
  loop {}
}
<span class="boring">}</span></code></pre></pre>
<p>You can put this in your project's <code>examples/</code> directory.
We'll call it <code>min1.rs</code>, and <code>cargo run --example min1</code> should build the example and run it in your runner.
If everything went fine, mGBA should open up and show a white screen and then do nothing, without any error messages.</p>
<p>If there's any problems already that's okay!
There's a lot of small details involved in something like this.
When I was setting things up for this book, and trying to write this minimal example, I messed it up at least three times.
Don't get discouraged too easily!
Double check all the file names, all the file contents, what you typed in the command line, and so on.
You can <a href="https://github.com/Lokathor/gba-from-scratch-rs/issues">open an issue</a> if you need to ask for help.
Alternately, you can try asking in the <a href="https://discord.io/gbadev">GBA Dev Discord</a>.</p>
<p>Let's cover each part of the example one at a time.</p>
<h2 id="crate-inner-attributes"><a class="header" href="#crate-inner-attributes">Crate Inner Attributes</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]
#![feature(naked_functions)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
<p>First we've got several &quot;inner&quot; attributes.
They're like normal attributes but they go just inside of what they affect, rather than just outside of it.
There's no way to have text &quot;outside&quot; of a file, so we have to use inner attributes here.
Inner attributes always have to go first, before any other items like functions or structs or anything like that.
The ordering of the attributes themselves doesn't matter,
I just like sorting them from shortest to longest because it usually looks nice.</p>
<p>First is <a href="https://doc.rust-lang.org/reference/names/preludes.html#the-no_std-attribute">no_std</a>.
This prevents the compiler from automatically linking our program with the <code>std</code> and <code>alloc</code> crates.
The GBA doesn't support <code>std</code> at all, so we'd get a build error if we didn't have <code>no_std</code>.
It's possible to use <code>alloc</code>, but we'd have to do more setup to make it work, so for now we can't.
Even without <code>std</code> available, we can still use a fairly good amount of Rust through the <code>core</code> crate.</p>
<p>Next is the <a href="https://doc.rust-lang.org/reference/crates-and-source-files.html#the-no_main-attribute">no_main</a> attribute.
Normally Rust would provide the actual <code>main</code> symbol which the OS calls at the start of the process.
That function does some environment setup and then calls the main function of the Rust code we wrote.
The compiler doesn't know how to write a <code>main</code> for the GBA though.
So, we just tell it to not even try, and we'll handle that ourselves.</p>
<p>Finally, we have a Nightly feature: <a href="https://github.com/rust-lang/rust/issues/90957">naked functions</a>.
Normally a function has the &quot;prologue&quot; and &quot;epilogue&quot; (the intro and outro) handled by the compiler.
This is for the best, because among other things it's what allows inlining to work.
However, on rare occasions we'll need to have the compiler step back and let us take complete control.
With the <code>naked_functions</code> Nightly feature, we'll be able to use <code>#[naked]</code> on a function when needed.</p>
<h2 id="entry-point"><a class="header" href="#entry-point">Entry Point</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[naked]
#[no_mangle]
#[instruction_set(arm::a32)]
#[link_section = &quot;.text.gba_rom_header&quot;]
unsafe extern &quot;C&quot; fn __start() -&gt; ! {
  core::arch::asm! {
    &quot;b 1f&quot;,
    &quot;.space 0xE0&quot;,
    &quot;1:&quot;,
    &quot;b 1b&quot;,
    options(noreturn)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>This is our <code>__start</code> function.
Normally we'd want to define one in a library, but for now it's fine to define it right in the example.</p>
<p>We call it <code>__start</code> and use <code>#[no_mangle]</code> to match the <code>ENTRY</code> part of our linker script.
Normally Rust would apply name mangling to a function's name so that its symbol name doesn't clash with any other (because name clashes cause a build error).
Using <code>#[no_mangle]</code> stops the name mangling from happening on a particular function or static (but we should limit how much we use it, to avoid those build errors).
It's the same idea as how <code>#[naked]</code> changes the (usually useful) default option into a weirder option.
We also use <code>#[link_section=]</code> to put this function into the &quot;.text.gba_rom_header&quot; section (also because of the linker script).
Section names can be alphanumeric, and they also allow underscores and periods.
The linker script will place the &quot;.text.gba_rom_header&quot; <em>input</em> section at the very start of the &quot;.text&quot; <em>output</em> section during linking.
That means that we'll end up with our <code>__start</code> function, and its header data, at the very start of the ROM.</p>
<p>The last attribute, <code>#[instruction_set(arm::a32)]</code>, sets the function to be encoded as <code>a32</code> instructions.
Because we're building using the <code>thumbv4t-none-eabi</code> target, all functions will <em>default</em> to being <code>t32</code>.
The <code>instruction_set</code> attribute lets us override the default and have an <code>a32</code> function.
Normally our functions can be <code>a32</code> or <code>t32</code>, and <code>t32</code> tends to have better performance by default.
Because of details about the GBA's boot up process (which we'll talk about below), the <code>__start</code> function always has to be <code>a32</code> specifically.</p>
<p>With all of the attributes out of the way, we get to declare the function itself: <code>unsafe extern &quot;C&quot; fn __start() -&gt; !</code>
We're gonna mark <code>__start</code> as <code>unsafe</code> because honestly no one should be calling it from Rust.
Our expectation is that only the BIOS itself will call <code>__start</code>, and only the once at boot.
So we'll just call the fn <code>unsafe</code> and say no one else can call it.
Similarly, because the BIOS will effectively be calling the function, we declare that the function has the <code>extern &quot;C&quot;</code> ABI.
It's Undefined Behavior (UB) for any code other than a Rust function to call a Rust ABI function, so we have to use the C ABI for <code>__start</code>.
It's just the rules.
Finally, we should never return from <code>__start</code>, so we put down the return type as <code>!</code>.
Actually this ends up being just a hint to future readers, because the compiler can't check the body of an inline assembly block.
Still, it's probably a useful hint, and I'm sure that future readers of the code (which might be ourselves!) will appreciate our guidance.</p>
<p>The body of a <code>#[naked]</code> function has to be a single <a href="https://doc.rust-lang.org/reference/inline-assembly.html">asm!</a> block.
Assembly blocks can be multi-line string literals, or they can be a list of string literals (the list is joined with newlines during compilation).
When we put the lines together the assembly looks like this:</p>
<pre><code class="language-arm">b 1f
.space 0xE0
1:
b 1b
</code></pre>
<ul>
<li>The first line is a &quot;branch&quot; (<code>b</code>) to the <code>1</code> label that's &quot;forward&quot; from this instruction (<code>1f</code>). In other words, the label on the third line of our asm block, where it says <code>1:</code>.</li>
<li>The second line is a directive to add blank space to the output. We can tell it's a directive because it starts with a dot. The <code>.space</code> directive just adds blank space to the program. In this case, 0xE0 (224 decimal) bytes of blank space goes right after the branch instruction. That's where the header data goes. For initial development with an emulator it's fine to have a blank header, so more on header stuff will come later. Blank space isn't useful code though, which is why the previous line jumps over the blank space to the label.</li>
<li>The third line <code>1:</code> is a label. We can tell it's a label because it ends with a <code>:</code> character. Within an <code>asm!</code> block you should only use numeric labels, which are always reusable without clashing. If you use <code>global_asm!</code>, or if you write an external assembly file, then you can also use alphanumeric labels if you're careful about which labels you export or not. A label marks the next instruction, either on the same line or on a future line. There can be more than one label pointing to the same instruction, and there can be blank lines between the label and the instruction. The number <code>1</code> itself isn't significant, we could pick any (positive, small-ish) number we like.</li>
<li>The fourth line is a branch to the <code>1</code> label that is &quot;back&quot; from this instruction (<code>1b</code>). This jumps to the label on line 3. That label refers to this instruction. So this instruction just jumps to this instruction, over and over. It's like writing <code>loop {}</code>, just the assembly version of it.</li>
</ul>
<p>In summary: our assembly block just jumps into an infinite loop.
It's not very exciting, but the emulator at least won't crash by trying to execute a blank part of the ROM or whatever.</p>
<h2 id="panic-handler"><a class="header" href="#panic-handler">Panic Handler</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[panic_handler]
fn handle_panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
  loop {}
}
<span class="boring">}</span></code></pre></pre>
<p>Even if the program itself can't actually panic, Rust demands that you define a panic handler function.
During compilation a panic handler that never gets called will be removed, the same as any function that's never called gets removed, but we have to define and then let the compiler decide for itself that it's unused.
As our programs grow we might want to have a panic handler that does something with the panic info.
Send a message to mGBA's debug output, or show something on the screen, or something like that.
Right now we'll start with a &quot;do nothing at all&quot; panic handle though.</p>
<h2 id="why-does-this-work"><a class="header" href="#why-does-this-work">Why Does This Work?</a></h2>
<p>The GBA has an ARM7TDMI CPU.
The ARM7TDMI uses the ARMv4T CPU architecture.
When the CPU turns on, the <code>pc</code> register (&quot;program counter&quot;) is reset to 0, and the CPU begins executing address 0.
This part is just how any ARM CPU works, it's not GBA specific.</p>
<p>Address 0 on the GBA is in the BIOS memory.
That's the &quot;Basic Input Output System&quot;.
The GBA's BIOS data is built into the device itself, separate from whichever cartridge you insert.
The BIOS has the code to play that <a href="https://www.youtube.com/watch?v=6_ZD3FxMcvQ">startup animation</a>, you know the one, with the nice sound.
It also checks the ROM's header data, and will lock the system if the header is incorrect.
We'll talk about header stuff more in a moment, but mGBA doesn't do the header check so for now it's fine to have a blank header.</p>
<p>After the BIOS has done all of its work it will branch to the start of the ROM, <code>0x0800_0000</code>.
That's where the linker script puts the start of the &quot;.text&quot; section.
And at the <em>very start</em> of the &quot;.text&quot; section will be the &quot;.text.gba_rom_header&quot; section.
The Rust compiler won't ever pick that for any code on its own, and we've only assigned one thing to use that section: our <code>__start</code> function.
So our <code>__start</code> function is going to be at the very very start of the ROM.
When the BIOS branches to the start of the ROM, it's branching to the <code>__start</code> function.
Then all the stuff we talked about up above with the four lines of assembly will happen.</p>
<p>And that's the basic idea of how this is working so far.
I still haven't explained the full story on the <code>instruction_set</code> and <code>a32</code> stuff,
but we'll save that for the next example.
For now, you can already call yourself a beginner GBA programmer!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-main"><a class="header" href="#calling-main">Calling <code>main</code></a></h1>
<p>A program that does nothing except not crash isn't much of a program.
Slightly more pressing is that defining <code>__start</code> within each and every example isn't a great way to do things.
First let's put the <code>__start</code> function in <code>lib.rs</code> so that all our examples will automatically get it when they link with our library.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs
#![no_std]
#![feature(naked_functions)]

#[naked]
#[no_mangle]
#[instruction_set(arm::a32)]
#[link_section = &quot;.text.gba_rom_header&quot;]
unsafe extern &quot;C&quot; fn __start() -&gt; ! {
  core::arch::asm! {
    // jump over the header data itself
    &quot;b 1f&quot;,
    &quot;.space 0xE0&quot;,
    &quot;1:&quot;,

    // call to `main`
    &quot;ldr r0, =main&quot;,
    &quot;bx r0&quot;,
    options(noreturn)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>This is <em>mostly</em> the same as before.
The difference is that we've replaced the <code>1: b 1b</code> loop with a call to a function named <code>main</code>.</p>
<pre><code class="language-arm">ldr r0, =main
bx r0
</code></pre>
<ul>
<li><code>ldr reg, =symbol</code> is a &quot;pseudo-instruction&quot; that the assembler supports.
The <code>ldr</code> instruction will &quot;load-register&quot;.
You can load an &quot;immediate&quot; value, which is a small value encoded within the instruction,
or you can load from an address stored in a register.
If you load from an address in a register you can also apply an offset.
This is how pointers to struct fields work: a base pointer and then some offset based on the field's position within a struct.
When we use <code>ldr reg, =symbol</code> the assembler will insert the address of <code>main</code> at the end of the function and then use the <code>pc</code> value (the program counter) as the base address to offset from.
It may sound complicated, but all of the lookups and math are handled for us by the assembler and linker.
We just write the  name of the symbol we want to end up in the register and it'll happen.
We could also write any large constant that doesn't fit in an immediate this way and the assembler will help us out.</li>
<li><code>bx r0</code> is a &quot;branch-exchange&quot; to the address stored in <code>r0</code>.
That's where we put the address of our <code>main</code> function, so the end of <code>__start</code> will branch-exchange to <code>main</code>.
The &quot;branch-exchange&quot; is a special type of branch that lets the CPU switch between ARM code (a32) and Thumb code (t32).
On the GBA's CPU it's the <em>only</em> way for user code to change code modes.
Later ARM CPUs relaxed this restriction, but on the GBA we've got to use <code>bx</code>.
Since <code>__start</code> is always a32 code, and the <code>main</code> function is almost always t32 code, we need to use <code>bx</code> and not just <code>b</code>.
Also of note is that <code>b</code> branches to a <em>label</em>, while <code>bx</code> branch-exchanges to a <em>register</em>.
Sometimes, like now, it's an extra step to load a function's address into a register when we want to use <code>bx</code>.</li>
</ul>
<p>So now we have a <code>__start</code> function that will call a <code>main</code> function.
But where's <code>main</code>?
It's not in the library at all.
It might seem like a problem to call a function that doesn't exist yet, but it's okay.
As long as <em>somewhere</em> defines <code>main</code> when actually linking an executable, the linker will connect everything together just fine.
If we try to make an example that doesn't define a <code>main</code> we'll get a linker error and the build will fail.</p>
<p>Now let's have a look at our second example.
We'll call it <code>min2.rs</code>.</p>
<p>First, we need the example to link to our library.
Normally this would happen automatically when the example calls any functions in the library or uses any types from the library.
Right now the library is nearly empty though, there's nothing to call, nothing to <code>use</code>.
We can force the library to be linked in with an <code>extern crate</code> statement,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in min2.rs
extern crate gba_from_scratch_rs;
<span class="boring">}</span></code></pre></pre>
<p>This won't be necessary in the future, but for now it will get the job done.</p>
<p>Next we need that <code>main</code> function.</p>
<pre><pre class="playground"><code class="language-rust">// in min2.rs
#[no_mangle]
extern &quot;C&quot; fn main() -&gt; ! {
  unsafe {
    (0x0500_0000 as *mut u16).write_volatile(0b11111);
    (0x0400_0000 as *mut u16).write_volatile(0);
  }
  loop {}
}</code></pre></pre>
<p>Like happened with <code>__start</code>, we need <code>main</code> to be <code>#[no_mangle]</code>.
This will allow the library to link with it during the linking of the executable.
Also like with <code>__start</code>, the return type of <code>main</code> will be <code>-&gt; !</code>, because we should never return from <code>main</code> back to <code>__start</code>.</p>
<p>The actual code in the body of <code>main</code> is two volatile writes.
These are to Memory-mapped IO (MMIO) addresses, which are how the CPU controls the rest of the hardware.
Most of learning to use the GBA well boils down to learning what all the MMIO controls allow for.
We'll go over the &quot;volatile&quot; part in the next lesson, but it is necessary to use a volatile write and not a normal write.</p>
<p>The first <code>write_volatile</code> call sets the color of the backdrop, the color that's shown for a pixel when nothing else is shown there.
Color values on the GBA are 5 bits per channel, red as the lowest bits, then green, then blue.</p>
<p>The second <code>write_volatile</code> sets the &quot;display control&quot; to 0.
When the BIOS first transfers control to our program, the display control is set with the &quot;forced blank&quot; bit on.
This is why the <code>min1</code> example was all white, because display was forced to be &quot;blank&quot;.
When we write 0 to the display control this disables the forced blank bit, allowing normal video display.
Since we haven't set anything else anywhere, the whole screen will be the backdrop color (which we set to red).</p>
<p>This means that our entire example does nothing but turn the screen red.
Still not very interactive, but it's some progress.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="volatile-ops"><a class="header" href="#volatile-ops">Volatile Ops</a></h1>
<p>In the previous lesson we used the <code>write_volatile</code> method of some pointers.
There's also a <code>read_volatile</code> method to go with it as well.
These both perform a &quot;volatile access&quot;.
Volatile memory accesses are special because they tell the compiler that a special side effect is going on.
It's a side effect that that compiler <em>does not</em> know about the specifics of.
This means that the compiler isn't free to alter the memory accesses themselves, because that would alter when the side effects happen too.</p>
<p>Let's have some examples of optimization affecting memory accesses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_thing(y: &amp;mut i32) {
  *y = 6;
  *y = 7;
}
<span class="boring">}</span></code></pre></pre>
<p>When we have code like this, the compiler will generally eliminate the step where 6 is written to <code>y</code>.
Instead, it will just write the value 7 to <code>y</code>.
That's normally great, because the best way to make a function fast is to cut down on the work it does.
However, if there was a side effect of the write, like if writing the value to a <em>special</em> address changed the hardware state via MMIO,
then losing some of our side effects would mean we lose some of our hardware state.</p>
<p>The same thing can be the case with reading memory as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn loop_until_it_is_10(y: &amp;mut i32) {
  while *y != 10 {}
}
<span class="boring">}</span></code></pre></pre>
<p>With standard memory the compiler would be totally justified in making this function read <code>y</code> just once to check for 10, and then infinitely loop after that if it wasn't 10.
Because if it's not 10 the first time, it won't be 10 the second time through the loop, or the next, or the next.
Except, what if we had a <em>special</em> MMIO address that gives the CPU some sort of info about the outside state, like button state or display state.
If that were the case, you'd definitely need to actually read the value and check against 10 every time the programmer said to.</p>
<p>Not only can the compiler eliminate memory reads and writes, but it can also even <em>add</em> memory reads in some situations.
If there's a reference (that doesn't contain an <code>UnsafeCell</code> based type), the compiler is allowed to &quot;speculatively&quot; read from the reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn might_read_ahead_of_time(y: &amp;i32, z: i32) -&gt; i32 {
  if complex_condition_check(z) {
    1 + *y
  } else {
    1 + z
  }
}
<span class="boring">}</span></code></pre></pre>
<p>According to the code we wrote, <code>y</code> is only supposed to be read from if the check function returns <code>true</code>.
However, because <code>y</code> is a reference, the compiler is <em>allowed</em> to read from <code>y</code> before the check function is called.
Memory is extremely slow to access, and modern CPUs can perform other work while they wait for memory accesses to complete.
In many cases it's <em>great</em> if the compiler can start the read of <code>y</code> earlier and have that happen while the check computation is going.
If it turns out the check fails, then the read result can just be discarded anyway.
But, again, if there's MMIO side effects involved, then reading memory earlier than expected might do something bad.</p>
<p>So this is where &quot;volatile&quot; comes in.
Volatile means &quot;please, just do it how I said to, trust me&quot;.</p>
<p>For all of our MMIO stuff:</p>
<ol>
<li>We <strong>don't</strong> want to use references.</li>
<li>We <strong>do</strong> want to use volatile.</li>
</ol>
<p>Unfortunately for us, the fundamental volatile read and write operations are defined for raw pointers.
Raw pointers are unsafe to use because anyone can just <em>make up</em> any raw pointer they want to at any time.
If you just pick a random pointer address and write some value to it, that could mess up anything at all.</p>
<p>We will be doing <em>a lot</em> of MMIO access, so we want as much of it as possible to all be done in safe code.
If we always work directly on raw pointers we'll have unsafe stuff spread everywhere.
It'll be super hard to tell where the actual dangerous parts of the program are.</p>
<p>And the thing is, most MMIO access is totally safe.
Writing a new backdrop color, or a new display control setting, can be done at any time.
There's a small number of cases where MMIO is not safe to do at any time, but those are rare.</p>
<p>So what we'll do is use the &quot;Unsafe Creation, Then Safe Use&quot; pattern.
Basically we'll make an alternate pointer type for our volatile access stuff.
It'll still be unsafe to make these volatile pointers, but once made they can be used as much as necessary from safe code.</p>
<h2 id="the-voladdress-type"><a class="header" href="#the-voladdress-type">The <code>VolAddress</code> type</a></h2>
<p>If you go use the <a href="https://docs.rs/gba">gba</a> crate, it defines MMIO addresses using the <a href="https://docs.rs/voladdress">voladdress</a> crate.
I promised that we'd write all our code from scratch, and we will do so, but we'll be keeping the design of our volatile pointer type very close to how the <code>voladdress</code> crate has it.
It's a lot less confusing to move between a tutorial and bigger &quot;real projects&quot; when the basic support layers are the same.
I wouldn't suggest that we use differently designed <code>Option</code> and <code>Result</code> types, so we should probably keep our <code>VolAddress</code> design similar as well.</p>
<p>Since the null address at 0 will never be a valid address for volatile reads and writes, let's wrap the <a href="https://doc.rust-lang.org/nightly/core/num/struct.NonZeroUsize.html">NonZeroUsize</a> type.
That way <code>VolAddress</code> and <code>Option&lt;VolAddress&gt;</code> will both fit in a single CPU register.
We know that the address can point to different types of things, so we've got to make it a generic type.
Our first attempt might look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in voladdress.rs

#[derive(Debug, Clone, Copy)]
#[repr(transparent)]
pub struct VolAddress&lt;T&gt; {
  address: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>but this doesn't work, we get a rather interesting error:</p>
<pre><code>error[E0392]: parameter `T` is never used    
 --&gt; src\voladdress.rs:8:23
  |
8 | pub struct VolAddress&lt;T&gt; {
  |                       ^ unused parameter
  |
  = help: consider removing `T`, referring to it in a field, or using a marker such as `PhantomData`
  = help: if you intended `T` to be a const parameter, use `const T: usize` instead
</code></pre>
<p>If there's going to be a generic target type <code>T</code> then we need to use it somewhere in the fields of the struct.
It's just a rule for how things work.
There's no actual <code>T</code> value we're storing, so let's use that <a href="https://doc.rust-lang.org/nightly/core/marker/struct.PhantomData.html">PhantomData</a> type it suggested.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]
#[repr(transparent)]
pub struct VolAddress&lt;T&gt; {
  address: NonZeroUsize,
  target: PhantomData&lt;T&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Now we've &quot;used&quot; the <code>T</code> in the <code>PhantomData</code>.
The <code>PhantomData</code> itself is a magical part of the language, it makes any generic parameter count as used without holding anything at all.</p>
<p>As I mentioned before, we'll have volatile addresses that are <em>usually</em> safe to read and write, but not always.
We can make extra generic parameters to help handle this too.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Safe;
pub struct Unsafe;

#[derive(Debug, Clone, Copy)]
#[repr(transparent)]
pub struct VolAddress&lt;T, R, W&gt; {
  address: NonZeroUsize,
  target: PhantomData&lt;T&gt;,
  read_status: PhantomData&lt;R&gt;,
  write_status: PhantomData&lt;W&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Now lets add a <code>read</code> method for our <code>VolAddress</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, W&gt; VolAddress&lt;T, Safe, W&gt;
where
  T: Copy,
{
  #[inline]
  pub fn read(self) -&gt; T {
    unsafe { (self.address.get() as *const T).read_volatile() }
  }
}

impl&lt;T, W&gt; VolAddress&lt;T, Unsafe, W&gt;
where
  T: Copy,
{
  #[inline]
  pub unsafe fn read(self) -&gt; T {
    (self.address.get() as *const T).read_volatile()
  }
}
<span class="boring">}</span></code></pre></pre>
<p>For a moment it might seem like we're defining <code>read</code> twice.
However, note that the <code>R</code> parameter of the type is different for each impl block.</p>
<ul>
<li>If the address is always safe to read then we make <code>R</code> be <code>Safe</code>, and the first method will be available.</li>
<li>If the address is unsafe to read we fill <code>R</code> with <code>Unsafe</code>, and the second method will be available instead.</li>
<li>If the address shouldn't be read at all then <code>R</code> can be <code>()</code> and then there won't be a <code>read</code> method.</li>
</ul>
<p>If that doesn't make sense right away that's okay.
When I first came up with the design it took me about 5 minutes to let it sink in that Rust would let me do it like this.
But, once you've understood it, I think it's a pretty great way to ensure the correct access is happening using the type system instead of runtime checks.</p>
<p>We can pull the same trick with <code>write</code> as well, using our <code>W</code> parameter:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, R&gt; VolAddress&lt;T, R, Safe&gt;
where
  T: Copy,
{
  #[inline]
  pub fn write(self, t: T) {
    unsafe { (self.address.get() as *mut T).write_volatile(t) }
  }
}

impl&lt;T, R&gt; VolAddress&lt;T, R, Unsafe&gt;
where
  T: Copy,
{
  #[inline]
  pub unsafe fn write(self, t: T) {
    (self.address.get() as *mut T).write_volatile(t)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The last thing we'll define right now is converting between <code>usize</code> values and <code>VolAddress</code> values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T, R, W&gt; VolAddress&lt;T, R, W&gt; where T: Copy {
  #[inline]
  #[must_use]
  pub const unsafe fn new(address: usize) -&gt; Self {
    assert!(address != 0);
    Self {
      address: NonZeroUsize::new_unchecked(address),
      target: PhantomData,
      read_status: PhantomData,
      write_status: PhantomData
    }
  }

  #[inline]
  #[must_use]
  pub const fn as_usize(self) -&gt; usize {
    self.address.get()
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="defining-an-mmio-address"><a class="header" href="#defining-an-mmio-address">Defining An MMIO Address</a></h2>
<p>Now that we've got a basic working <code>VolAddress</code> type let's put it to use.
The two addresses we've seen so far are the backdrop color and the display control.
Defining the display control would involve a lot of bitwise ops stuff, so we'll put that off for later.</p>
<p>Let's handle the backdrop address by first defining a type for colors.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// New library module: color.rs

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
pub struct Color(pub u16);
<span class="boring">}</span></code></pre></pre>
<p>Any time we define a type for use with MMIO, we want to be sure it's a <code>#[repr(transparent)]</code> wrapper around one of the 1, 2, or 4 byte int types (<code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, or <code>i32</code>).
That way the actual memory access can always happen as a single instruction.
If a type's size doesn't allow it to be accessed from memory as a single instruction then the compiler is free to just &quot;do its best&quot;.
The code will do some instruction sequence that eventually gets a value, but with MMIO we want to have high confidence about exactly what's going on.
That's why we're sticking to only wrapping the native int types with our MMIO types.</p>
<p>Anyway, a <code>Color</code> is 5 bits per channel, and any bit pattern is valid, so we can make the field be <code>pub</code>.
We could have all sorts of other methods, but just the base definition is sufficient to define our backdrop address.
Let's try to keep our MMIO definitions in a single file if we can.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// New library module: mmio.rs

pub const BACKDROP_COLOR: VolAddress&lt;Color, Safe, Safe&gt; = unsafe { VolAddress::new(0x0500_0000) };
<span class="boring">}</span></code></pre></pre>
<p>And since we're starting to have a lot of modules let's make a prelude for our library.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// New library module: prelude.rs

pub use crate::color::*;
pub use crate::mmio::*;
pub use crate::voladdress::*;
<span class="boring">}</span></code></pre></pre>
<p>So hopefully our examples can just import the library prelude, instead of importing all sorts of individual little types.
Because we're gonna have a lot of types as we go.</p>
<p>And every time we add one of these library modules we need to update the parent module, which is <code>lib.rs</code> in this case</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in lib.rs
pub mod voladdress;
pub mod color;
pub mod mmio;
pub mod prelude;
<span class="boring">}</span></code></pre></pre>
<p>From now on when there's new module files remember to declare the module in the parent, even if I don't say that part.</p>
<p>Okay, now that everything is all set in the library, we can make a new <code>min3.rs</code> example.</p>
<pre><pre class="playground"><code class="language-rust">// New Example: min3.rs
#![no_std]
#![no_main]

use gba_from_scratch_rs::prelude::*;

#[no_mangle]
extern &quot;C&quot; fn main() -&gt; ! {
  BACKDROP_COLOR.write(Color(0b11111));
  
  unsafe {
    (0x0400_0000 as *mut u16).write_volatile(0);
  }
  loop {}
}

#[panic_handler]
fn handle_panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
  loop {}
}</code></pre></pre>
<p>And this new example... turns the screen red.
Exactly the same as the last example.
It might seem like we said a lot and didn't accomplish much, but we've moved part of the program out of the <code>unsafe</code> block.
It's always worth it when you can learn a bit and then move code out of an <code>unsafe</code> block and over to the safe portion of the program.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
